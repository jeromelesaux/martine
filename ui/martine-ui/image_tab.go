package ui

import (
	"fmt"
	"image/color"
	"os"
	"path/filepath"
	"strconv"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/data/validation"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/layout"
	"fyne.io/fyne/v2/theme"
	"fyne.io/fyne/v2/widget"
	wgt "github.com/jeromelesaux/fyne-io/widget"
	"github.com/jeromelesaux/fyne-io/widget/editor"
	"github.com/jeromelesaux/martine/constants"
	"github.com/jeromelesaux/martine/convert/image"
	"github.com/jeromelesaux/martine/export/amsdos"
	"github.com/jeromelesaux/martine/export/ascii"
	"github.com/jeromelesaux/martine/export/diskimage"
	impPalette "github.com/jeromelesaux/martine/export/impdraw/palette"
	"github.com/jeromelesaux/martine/export/m4"
	"github.com/jeromelesaux/martine/log"

	"github.com/jeromelesaux/martine/export/png"
	"github.com/jeromelesaux/martine/export/snapshot"
	"github.com/jeromelesaux/martine/gfx"
	"github.com/jeromelesaux/martine/ui/martine-ui/directory"
	"github.com/jeromelesaux/martine/ui/martine-ui/menu"
	w2 "github.com/jeromelesaux/martine/ui/martine-ui/widget"
)

type dialogIface interface {
	Show()
}

func (m *MartineUI) CheckAmsdosHeaderExport(inDsk, addAmsdosHeader bool, d dialogIface, win fyne.Window) {
	if inDsk && !addAmsdosHeader {
		dialog.NewConfirm("Warning",
			"You are about to export files in DSK without Amsdos header, continue ? ",
			func(b bool) {
				if b {
					d.Show()
				} else {
					return
				}
			},
			win).Show()

	} else {
		d.Show()
	}
}

// nolint: funlen, gocognit
func (m *MartineUI) ExportOneImage(me *menu.ImageMenu) {
	pi := wgt.NewProgressInfinite("Saving...., Please wait.", m.window)
	pi.Show()
	cfg := m.NewConfig(me, true)
	if cfg == nil {
		return
	}
	if m.imageExport.ExportText {
		if cfg.Overscan {
			cfg.ExportAsGoFile = true
		}

		out, _, palette, _, err := gfx.ApplyOneImage(me.OriginalImage().Image, cfg, me.Mode, me.Palette(), uint8(me.Mode))
		if err != nil {
			pi.Hide()
			dialog.ShowError(err, m.window)
			return
		}
		code := ascii.FormatAssemblyDatabyte(out, "\n")
		palCode := ascii.FormatAssemblyCPCPalette(palette, "\n")
		content := fmt.Sprintf("; Generated by martine\n; from file %s\nImage:\n%s\n\n; palette\npalette: \n%s\n ",
			me.OriginalImagePath(),
			code,
			palCode)
		filename := filepath.Base(me.OriginalImagePath())
		fileExport := m.imageExport.ExportFolderPath + string(filepath.Separator) + filename + ".asm"
		if err = amsdos.SaveStringOSFile(fileExport, content); err != nil {
			pi.Hide()
			dialog.ShowError(err, m.window)
			return
		}
	} else {
		// palette export
		userDir, err := os.UserHomeDir()
		if err != nil {
			pi.Hide()
			dialog.ShowError(err, m.window)
		}
		tmpPalette := userDir + string(filepath.Separator) + "temporary_palette.kit"
		if err := impPalette.SaveKit(tmpPalette, me.Palette(), false); err != nil {
			pi.Hide()
			dialog.ShowError(err, m.window)
		}
		if me.UsePalette {
			cfg.KitPath = tmpPalette
		}

		filename := filepath.Base(me.OriginalImagePath())
		if me.Edited {
			err = gfx.ExportRawImage(
				me.CpcImage().Image,
				me.Palette(),
				cfg,
				filename,
				m.imageExport.ExportFolderPath+string(filepath.Separator)+filename,
				uint8(me.Mode),
			)
		} else {
			err = gfx.ApplyOneImageAndExport(
				me.OriginalImage().Image,
				cfg,
				filename,
				m.imageExport.ExportFolderPath+string(filepath.Separator)+filename,
				me.Mode,
				uint8(me.Mode))
		}
		os.Remove(tmpPalette)

		if err != nil {
			pi.Hide()
			dialog.NewError(err, m.window).Show()
			return
		}
		if cfg.Dsk {
			if err := diskimage.ImportInDsk(me.OriginalImagePath(), cfg); err != nil {
				dialog.NewError(err, m.window).Show()
				return
			}
		}
		if cfg.Sna {
			if cfg.Overscan {
				var gfxFile string
				for _, v := range cfg.DskFiles {
					if filepath.Ext(v) == ".SCR" {
						gfxFile = v
						break
					}
				}
				cfg.SnaPath = filepath.Join(m.imageExport.ExportFolderPath, "test.sna")
				if err := snapshot.ImportInSna(gfxFile, cfg.SnaPath, uint8(me.Mode)); err != nil {
					dialog.NewError(err, m.window).Show()
					return
				}
			}
		}
	}
	if m.imageExport.ExportToM2 {
		if err := m4.ImportInM4(cfg); err != nil {
			dialog.NewError(err, m.window).Show()
			log.GetLogger().Error("Cannot send to M4 error :%v\n", err)
		}
	}
	pi.Hide()
	dialog.ShowInformation("Save", "Your files are save in folder \n"+m.imageExport.ExportFolderPath, m.window)
}

func (m *MartineUI) monochromeColor(c color.Color) {
	m.main.SetPalette(image.ColorMonochromePalette(c, m.main.Palette()))
	m.main.SetPaletteImage(png.PalToImage(m.main.Palette()))
}

func (m *MartineUI) ApplyOneImage(me *menu.ImageMenu) {
	me.Edited = false
	cfg := m.NewConfig(me, true)
	if cfg == nil {
		return
	}

	var inPalette color.Palette
	if me.UsePalette {
		inPalette = me.Palette()
		maxPalette := len(inPalette)
		switch me.Mode {
		case 1:
			if maxPalette > 4 {
				maxPalette = 4
			}
			inPalette = inPalette[0:maxPalette]
		case 2:
			if maxPalette > 2 {
				maxPalette = 2
			}
			inPalette = inPalette[0:maxPalette]
		}

	}
	pi := wgt.NewProgressInfinite("Computing, Please wait.", m.window)
	pi.Show()
	out, downgraded, palette, _, err := gfx.ApplyOneImage(me.OriginalImage().Image, cfg, me.Mode, inPalette, uint8(me.Mode))
	pi.Hide()
	if err != nil {
		dialog.NewError(err, m.window).Show()
		return
	}
	me.Data = out
	me.Downgraded = downgraded
	if !me.UsePalette {
		me.SetPalette(palette)
	}
	if me.IsSprite || me.IsHardSprite {
		newSize := constants.Size{Width: cfg.Size.Width * 50, Height: cfg.Size.Height * 50}
		me.Downgraded = image.Resize(me.Downgraded, newSize, me.ResizeAlgo)
	}
	me.SetCpcImage(me.Downgraded)
	me.SetPaletteImage(png.PalToImage(me.Palette()))
}

// nolint: funlen
func (m *MartineUI) newImageTransfertTab(me *menu.ImageMenu) *fyne.Container {
	importOpen := newImportButton(m, me)

	paletteOpen := NewOpenPaletteButton(me, m.window)

	forcePalette := widget.NewCheck("use palette", func(b bool) {
		me.UsePalette = b
	})

	openFileWidget := widget.NewButton("Image", func() {
		d := dialog.NewFileOpen(func(reader fyne.URIReadCloser, err error) {
			if err != nil {
				dialog.ShowError(err, m.window)
				return
			}
			if reader == nil {
				return
			}
			directory.SetImportDirectoryURI(reader.URI())
			me.SetOriginalImagePath(reader.URI())
			img, err := openImage(me.OriginalImagePath())
			if err != nil {
				dialog.ShowError(err, m.window)
				return
			}
			me.SetOriginalImage(img)
			// m.window.Canvas().Refresh(&me.OriginalImage)
			// m.window.Resize(m.window.Content().Size())
		}, m.window)
		path, err := directory.ImportDirectoryURI()
		if err == nil {
			d.SetLocation(path)
		}
		d.SetFilter(imagesFilesFilter)
		d.Resize(dialogSize)
		d.Show()
	})

	exportButton := widget.NewButtonWithIcon("Export", theme.DocumentSaveIcon(), func() {
		m.exportDialog(m.imageExport, m.window)
	})

	applyButton := widget.NewButtonWithIcon("Apply", theme.VisibilityIcon(), func() {
		log.GetLogger().Infoln("apply.")
		m.ApplyOneImage(me)
	})

	openFileWidget.Icon = theme.FileImageIcon()

	winFormat := w2.NewWinFormatRadio(me)

	colorReducerLabel := widget.NewLabel("Color reducer")
	colorReducer := widget.NewSelect([]string{"none", "Lower", "Medium", "Strong"}, func(s string) {
		switch s {
		case "none":
			me.Reducer = 0
		case "Lower":
			me.Reducer = 1
		case "Medium":
			me.Reducer = 2
		case "Strong":
			me.Reducer = 3
		}
	})
	colorReducer.SetSelected("none")

	resize := w2.NewResizeAlgorithmSelect(me)
	resizeLabel := widget.NewLabel("Resize algorithm")

	kmeansLabel := widget.NewLabel("Reduce palette with Kmeans")
	useKmeans := widget.NewCheck("Use Kmeans", func(b bool) {
		me.UseKmeans = b
	})
	kmeansIteration := widget.NewSlider(0.01, .9)
	kmeansIteration.SetValue(.01)
	kmeansIteration.Step = .01
	kmeansIteration.OnChanged = func(f float64) {
		me.KmeansThreshold = f
	}

	ditheringMultiplier := widget.NewSlider(0., 5.)
	ditheringMultiplier.Step = 0.1
	ditheringMultiplier.SetValue(.1)
	ditheringMultiplier.OnChanged = func(f float64) {
		me.DitheringMultiplier = f
	}
	dithering := w2.NewDitheringSelect(me)

	ditheringWithQuantification := widget.NewCheck("With quantification", func(b bool) {
		me.WithQuantification = b
	})

	enableDithering := widget.NewCheck("Enable dithering", func(b bool) {
		me.ApplyDithering = b
	})
	isPlus := widget.NewCheck("CPC Plus", func(b bool) {
		me.IsCpcPlus = b
	})

	oneLine := widget.NewCheck("Every other line", func(b bool) {
		me.OneLine = b
	})
	oneRow := widget.NewCheck("Every other row", func(b bool) {
		me.OneRow = b
	})
	modes := widget.NewSelect([]string{"0", "1", "2"}, func(s string) {
		mode, err := strconv.Atoi(s)
		if err != nil {
			log.GetLogger().Error("Error %s cannot be cast in int\n", s)
		}
		me.Mode = mode
	})
	modes.SetSelected("0")
	modeSelection = modes
	modeLabel := widget.NewLabel("Mode:")

	widthLabel := widget.NewLabel("Width")
	me.Width().Validator = validation.NewRegexp("\\d+", "Must contain a number")

	heightLabel := widget.NewLabel("Height")
	me.Height().Validator = validation.NewRegexp("\\d+", "Must contain a number")

	brightness := widget.NewSlider(0.0, 1.0)
	brightness.SetValue(1.)
	brightness.Step = .01
	brightness.OnChanged = func(f float64) {
		me.Brightness = f
	}
	saturationLabel := widget.NewLabel("Saturation")
	saturation := widget.NewSlider(0.0, 1.0)
	saturation.SetValue(1.)
	saturation.Step = .01
	saturation.OnChanged = func(f float64) {
		me.Saturation = f
	}
	brightnessLabel := widget.NewLabel("Brightness")

	warningLabel := widget.NewLabel("Setting thoses parameters will affect your palette, you can't force palette.")
	warningLabel.TextStyle = fyne.TextStyle{Bold: true}

	editButton := widget.NewButtonWithIcon("Edit", theme.DocumentCreateIcon(), func() {
		p := constants.CpcOldPalette
		if me.IsCpcPlus {
			p = constants.CpcPlusPalette
		}
		if me.CpcImage().Image == nil || me.PaletteImage().Image == nil {
			return
		}
		edit := editor.NewEditor(me.CpcImage().Image,
			editor.MagnifyX2,
			me.Palette(),
			p, me.SetImagePalette,
			m.window)

		d := dialog.NewCustom("Editor", "Ok", edit.NewEditor(), m.window)
		size := m.window.Content().Size()
		size = fyne.Size{Width: size.Width, Height: size.Height}
		d.Resize(size)
		d.Show()
		// after the me.CpcImage().Image must be used to export
	})

	return container.New(
		layout.NewGridLayoutWithColumns(2),
		container.New(
			layout.NewGridLayoutWithRows(2),
			container.NewScroll(
				me.OriginalImage()),
			container.NewScroll(
				me.CpcImage()),
		),
		container.New(
			layout.NewVBoxLayout(),
			container.New(
				layout.NewHBoxLayout(),
				openFileWidget,
				paletteOpen,
				applyButton,
				exportButton,
				importOpen,
				editButton,
			),
			container.New(
				layout.NewHBoxLayout(),
				isPlus,
				winFormat,

				container.New(
					layout.NewVBoxLayout(),
					container.New(
						layout.NewVBoxLayout(),
						modeLabel,
						modes,
					),
					container.New(
						layout.NewHBoxLayout(),
						widthLabel,
						me.Width(),
					),
					container.New(
						layout.NewHBoxLayout(),
						heightLabel,
						me.Height(),
					),
				),
			),
			container.New(
				layout.NewGridLayoutWithRows(7),
				container.New(
					layout.NewGridLayoutWithRows(3),
					container.New(
						layout.NewGridLayoutWithColumns(3),
						kmeansLabel,
						useKmeans,
						kmeansIteration,
					),
					container.New(
						layout.NewGridLayoutWithColumns(2),
						resizeLabel,
						resize,
					),
					container.New(
						layout.NewGridLayoutWithColumns(4),
						enableDithering,
						dithering,
						ditheringMultiplier,
						ditheringWithQuantification,
					),
				),
				container.New(
					layout.NewGridLayoutWithRows(2),
					oneLine,
					oneRow,
				),
				container.New(
					layout.NewGridLayoutWithRows(2),
					me.PaletteImage(),
					container.New(
						layout.NewHBoxLayout(),
						forcePalette,
						widget.NewButtonWithIcon("Swap", theme.ColorChromaticIcon(), func() {
							w2.SwapColor(m.SetPalette, me.Palette(), m.window, func() {
								forcePalette.SetChecked(true)
							})
						}),
						m.newImageMenuExportButton(me),
						widget.NewButton("Gray", func() {
							if me.IsCpcPlus {
								me.SetPalette(image.MonochromePalette(me.Palette()))
								me.SetPaletteImage(png.PalToImage(me.Palette()))
								forcePalette.SetChecked(true)
								forcePalette.Refresh()
							}
						}),

						widget.NewButton("Monochome", func() {
							if me.IsCpcPlus {
								w2.ColorSelector(m.monochromeColor, me.Palette(), m.window, func() {
									forcePalette.SetChecked(true)
								})
							}
						}),
					),
				),
				container.New(
					layout.NewVBoxLayout(),
					warningLabel,
				),
				container.New(
					layout.NewVBoxLayout(),
					colorReducerLabel,
					colorReducer,
				),
				container.New(
					layout.NewVBoxLayout(),
					brightnessLabel,
					brightness,
				),
				container.New(
					layout.NewVBoxLayout(),
					saturationLabel,
					saturation,
					widget.NewButton("show cmd", func() {
						e := widget.NewMultiLineEntry()
						e.SetText(me.CmdLine())

						d := dialog.NewCustom("Command line generated",
							"Ok",
							e,
							m.window)
						log.GetLogger().Info("%s\n", me.CmdLine())
						size := m.window.Content().Size()
						size = fyne.Size{Width: size.Width / 2, Height: size.Height / 2}
						d.Resize(size)
						d.Show()
					}),
				),
			),
		),
	)
}
